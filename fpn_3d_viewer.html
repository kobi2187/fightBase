<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>MPN 3D Mannequin Viewer</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #2a2a2a;
      display: flex;
    }

    #controls {
      width: 380px;
      height: 100vh;
      overflow-y: auto;
      background: rgba(255,255,255,0.95);
      padding: 20px;
      box-shadow: 2px 0 8px rgba(0,0,0,0.3);
    }

    #canvas-container {
      flex: 1;
      height: 100vh;
    }

    h2 {
      margin: 0 0 15px 0;
      font-size: 18px;
    }

    h3 {
      margin: 20px 0 10px 0;
      font-size: 14px;
      color: #333;
      border-bottom: 2px solid #4CAF50;
      padding-bottom: 5px;
    }

    .fighter-select {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .fighter-btn {
      flex: 1;
      padding: 10px;
      border: 2px solid #ddd;
      background: white;
      cursor: pointer;
      border-radius: 4px;
      font-weight: bold;
    }

    .fighter-btn.active {
      border-color: #4CAF50;
      background: #e8f5e9;
    }

    .slider-group {
      margin-bottom: 15px;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      margin-bottom: 3px;
      color: #555;
    }

    .slider-value {
      font-weight: bold;
      color: #4CAF50;
    }

    input[type="range"] {
      width: 100%;
      margin: 5px 0;
    }

    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 16px;
      font-size: 13px;
      border-radius: 4px;
      cursor: pointer;
      width: 100%;
      margin-top: 10px;
    }

    button:hover {
      background: #45a049;
    }

    .example-btn {
      background: #2196F3;
      font-size: 11px;
      padding: 8px;
      margin-top: 5px;
    }

    .example-btn:hover {
      background: #0b7dda;
    }

    .distance-select {
      width: 100%;
      padding: 8px;
      margin-top: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .info {
      font-size: 11px;
      color: #666;
      background: #f5f5f5;
      padding: 8px;
      border-radius: 4px;
      margin-top: 10px;
    }

    #mpn-output {
      font-family: monospace;
      font-size: 10px;
      background: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
      word-break: break-all;
      max-height: 100px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div id="controls">
    <h2>ðŸ¥‹ Mannequin Pose Editor</h2>

    <div class="fighter-select">
      <button class="fighter-btn active" onclick="selectFighter('A')">Fighter A (Red)</button>
      <button class="fighter-btn" onclick="selectFighter('B')">Fighter B (Blue)</button>
    </div>

    <h3>Body Position</h3>
    <div class="slider-group">
      <div class="slider-label">
        <span>Torso Lean Forward/Back (from hip)</span>
        <span class="slider-value" id="val-lean-fb">0Â°</span>
      </div>
      <input type="range" id="lean-fb" min="-45" max="45" value="0" step="1" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Torso Lean Left/Right (from hip)</span>
        <span class="slider-value" id="val-lean-lr">0Â°</span>
      </div>
      <input type="range" id="lean-lr" min="-45" max="45" value="0" step="1" oninput="updatePose()">
    </div>

    <h3>Torso Rotation</h3>
    <div class="slider-group">
      <div class="slider-label">
        <span>Hip Rotation</span>
        <span class="slider-value" id="val-hip-rot">0Â°</span>
      </div>
      <input type="range" id="hip-rot" min="-45" max="45" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Torso Rotation (relative to hips)</span>
        <span class="slider-value" id="val-torso-rot">0Â°</span>
      </div>
      <input type="range" id="torso-rot" min="-45" max="45" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Neck/Head Turn</span>
        <span class="slider-value" id="val-neck-rot">0Â°</span>
      </div>
      <input type="range" id="neck-rot" min="-60" max="60" value="0" step="5" oninput="updatePose()">
    </div>

    <h3>Arms</h3>
    <div class="slider-group">
      <div class="slider-label">
        <span>Left Shoulder Pitch (forward/up)</span>
        <span class="slider-value" id="val-l-shoulder-p">0Â°</span>
      </div>
      <input type="range" id="l-shoulder-p" min="-60" max="180" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Left Shoulder Roll (raise sideways)</span>
        <span class="slider-value" id="val-l-shoulder-r">0Â°</span>
      </div>
      <input type="range" id="l-shoulder-r" min="0" max="180" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Left Shoulder Yaw (internal/external rotation)</span>
        <span class="slider-value" id="val-l-shoulder-y">0Â°</span>
      </div>
      <input type="range" id="l-shoulder-y" min="-90" max="90" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Left Elbow Bend</span>
        <span class="slider-value" id="val-l-elbow">90Â°</span>
      </div>
      <input type="range" id="l-elbow" min="0" max="150" value="90" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Right Shoulder Pitch (forward/up)</span>
        <span class="slider-value" id="val-r-shoulder-p">0Â°</span>
      </div>
      <input type="range" id="r-shoulder-p" min="-60" max="180" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Right Shoulder Roll (raise sideways)</span>
        <span class="slider-value" id="val-r-shoulder-r">0Â°</span>
      </div>
      <input type="range" id="r-shoulder-r" min="0" max="180" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Right Shoulder Yaw (internal/external rotation)</span>
        <span class="slider-value" id="val-r-shoulder-y">45Â°</span>
      </div>
      <input type="range" id="r-shoulder-y" min="-90" max="90" value="45" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Right Elbow Bend</span>
        <span class="slider-value" id="val-r-elbow">90Â°</span>
      </div>
      <input type="range" id="r-elbow" min="0" max="150" value="90" step="5" oninput="updatePose()">
    </div>

    <h3>Legs</h3>
    <div class="slider-group">
      <div class="slider-label">
        <span>Left Hip Pitch (kick forward/back)</span>
        <span class="slider-value" id="val-l-hip-p">0Â°</span>
      </div>
      <input type="range" id="l-hip-p" min="-30" max="200" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Left Hip Roll (sideways)</span>
        <span class="slider-value" id="val-l-hip-r">0Â°</span>
      </div>
      <input type="range" id="l-hip-r" min="-45" max="45" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Left Hip Yaw (leg rotation inward/outward)</span>
        <span class="slider-value" id="val-l-hip-y">0Â°</span>
      </div>
      <input type="range" id="l-hip-y" min="-90" max="90" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Left Knee Bend</span>
        <span class="slider-value" id="val-l-knee">15Â°</span>
      </div>
      <input type="range" id="l-knee" min="0" max="140" value="15" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Right Hip Pitch (kick forward/back)</span>
        <span class="slider-value" id="val-r-hip-p">0Â°</span>
      </div>
      <input type="range" id="r-hip-p" min="-30" max="200" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Right Hip Roll (sideways)</span>
        <span class="slider-value" id="val-r-hip-r">0Â°</span>
      </div>
      <input type="range" id="r-hip-r" min="-45" max="45" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Right Hip Yaw (leg rotation inward/outward)</span>
        <span class="slider-value" id="val-r-hip-y">0Â°</span>
      </div>
      <input type="range" id="r-hip-y" min="-90" max="90" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Right Knee Bend</span>
        <span class="slider-value" id="val-r-knee">15Â°</span>
      </div>
      <input type="range" id="r-knee" min="0" max="140" value="15" step="5" oninput="updatePose()">
    </div>

    <h3>Stance</h3>
    <div class="slider-group">
      <div class="slider-label">
        <span>Stance Width</span>
        <span class="slider-value" id="val-stance">40 cm</span>
      </div>
      <input type="range" id="stance" min="20" max="80" value="40" step="2" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Distance Between Fighters</span>
      </div>
      <select class="distance-select" id="distance" onchange="updatePose()">
        <option value="c">Contact (1.5m)</option>
        <option value="s">Short (2.5m)</option>
        <option value="m" selected>Medium (4m)</option>
        <option value="l">Long (6m)</option>
        <option value="v">Very Long (8m)</option>
      </select>
    </div>

    <button onclick="resetPose()">Reset Current Fighter</button>
    <button onclick="resetBoth()">Reset Both Fighters</button>
    <button onclick="randomPose()" style="background: #FF9800;">ðŸŽ² Random Pose</button>

    <h3>Preset Poses</h3>
    <button class="example-btn" onclick="loadPreset('neutral')">Neutral Stance</button>
    <button class="example-btn" onclick="loadPreset('jab')">Jab</button>
    <button class="example-btn" onclick="loadPreset('guard')">Guard Position</button>
    <button class="example-btn" onclick="loadPreset('kick')">Front Kick</button>
    <button class="example-btn" onclick="loadPreset('highkick')">High Kick to Head</button>
    <button class="example-btn" onclick="loadPreset('hook')">Hook Punch</button>

    <div class="info">
      <strong>MPN Output:</strong>
      <div id="mpn-output"></div>
    </div>
  </div>

  <div id="canvas-container"></div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // State
    let scene, camera, renderer;
    let fighterA, fighterB;
    let currentFighter = 'A';

    // Pose data for both fighters
    let poseA = createNeutralPose();
    let poseB = createNeutralPose();

    function createNeutralPose() {
      return {
        leanForwardBack: 0,
        leanLeftRight: 0,
        hipRotation: 0,
        torsoRotation: 0,
        neckRotation: 0,
        leftShoulderPitch: 0,
        leftShoulderRoll: 0,
        leftShoulderYaw: 0,
        rightShoulderPitch: 0,
        rightShoulderRoll: 0,
        rightShoulderYaw: 45,  // Rear guard rotated inward to protect jaw
        leftElbowBend: 90,
        rightElbowBend: 90,
        leftHipPitch: 0,
        leftHipRoll: 0,
        leftHipYaw: 0,
        rightHipPitch: 0,
        rightHipRoll: 0,
        rightHipYaw: 0,
        leftKneeBend: 15,
        rightKneeBend: 15,
        stanceWidth: 40
      };
    }

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x2a2a2a);

      // Camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 6);
      camera.lookAt(0, 2, 0);

      // Renderer
      const container = document.getElementById('canvas-container');
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
      mainLight.position.set(5, 10, 5);
      mainLight.castShadow = true;
      scene.add(mainLight);

      // Ground
      const groundGeometry = new THREE.PlaneGeometry(20, 20);
      const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
      const groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
      groundPlane.rotation.x = -Math.PI / 2;
      groundPlane.receiveShadow = true;
      scene.add(groundPlane);

      const gridHelper = new THREE.GridHelper(20, 20, 0x666666, 0x333333);
      scene.add(gridHelper);

      // Create mannequins with wooden colors
      fighterA = createMannequin(0xd2a679);  // Light wood tone
      fighterB = createMannequin(0xa67c52);  // Darker wood tone

      fighterA.position.set(-2, 0, 0);
      fighterB.position.set(2, 0, 0);
      fighterA.rotation.y = -Math.PI / 2;   // Face right (+X direction, toward B)
      fighterB.rotation.y = Math.PI / 2;    // Face left (-X direction, toward A)

      scene.add(fighterA);
      scene.add(fighterB);

      // Mouse controls
      setupMouseControls();

      // Initial update
      updatePose();

      // Render loop
      animate();

      window.addEventListener('resize', onWindowResize);
    }

    function createMannequin(color) {
      const mannequin = new THREE.Group();

      // Create two-tone materials for wooden mannequin (outer lighter, inner darker)
      const outerColor = new THREE.Color(color).multiplyScalar(1.1); // Lighter outer
      const innerColor = new THREE.Color(color).multiplyScalar(0.75); // Darker inner

      const outerMaterial = new THREE.MeshStandardMaterial({
        color: outerColor,
        roughness: 0.8,
        metalness: 0.0
      });
      const innerMaterial = new THREE.MeshStandardMaterial({
        color: innerColor,
        roughness: 0.8,
        metalness: 0.0
      });
      const jointMaterial = new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.8,
        metalness: 0.0
      });

      // Default material (will use outer for most parts)
      const material = outerMaterial;

      // Build from ground up using forward kinematics
      // Root is at ground level (y=0)

      // Hips - the root of the kinematic chain (connected to ground)
      const hipsGroup = new THREE.Group();
      hipsGroup.position.y = 1.05; // Height from ground to hip joint
      hipsGroup.name = 'hips';

      const hipsMesh = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.3, 0.3), material);
      hipsMesh.castShadow = true;
      hipsGroup.add(hipsMesh);

      mannequin.add(hipsGroup);

      // Torso - connected to hips
      const torsoGroup = new THREE.Group();
      torsoGroup.position.y = 0.55; // Distance from hip center to torso center
      torsoGroup.name = 'torso';

      // Torso front (chest - lighter)
      const torsoMesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.8, 0.3), outerMaterial);
      torsoMesh.castShadow = true;
      torsoGroup.add(torsoMesh);

      // Torso back (darker)
      const torsoBack = new THREE.Mesh(
        new THREE.BoxGeometry(0.48, 0.78, 0.03),
        innerMaterial
      );
      torsoBack.position.z = -0.135;
      torsoBack.castShadow = true;
      torsoGroup.add(torsoBack);

      hipsGroup.add(torsoGroup); // Torso is child of hips

      // Neck - connected to top of torso
      const neckGroup = new THREE.Group();
      neckGroup.position.y = 0.475; // From torso center to neck base
      neckGroup.name = 'neck';

      // Neck joint sphere (visible ball joint)
      const neckJoint = new THREE.Mesh(new THREE.SphereGeometry(0.09, 12, 12), jointMaterial);
      neckJoint.castShadow = true;
      neckGroup.add(neckJoint);

      const neckMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.15, 8), material);
      neckMesh.position.y = 0.075; // Neck mesh offset
      neckMesh.castShadow = true;
      neckGroup.add(neckMesh);

      torsoGroup.add(neckGroup); // Neck is child of torso

      // Head - connected to neck
      const headGroup = new THREE.Group();
      headGroup.position.y = 0.15; // From neck base to head center
      headGroup.name = 'head';

      const headMesh = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), material);
      headMesh.position.y = 0.2; // Head mesh offset
      headMesh.castShadow = true;
      headGroup.add(headMesh);

      // Nose - cone pointing forward to show orientation
      const noseMaterial = new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.8,
        metalness: 0.0
      });
      const noseGeometry = new THREE.ConeGeometry(0.04, 0.12, 8);
      const noseMesh = new THREE.Mesh(noseGeometry, noseMaterial);
      noseMesh.position.set(0, 0.2, 0.16); // Stick out from front of head
      noseMesh.rotation.x = Math.PI / 2; // Point forward
      noseMesh.castShadow = true;
      headGroup.add(noseMesh);

      neckGroup.add(headGroup); // Head is child of neck

      // Arms - function to create arm connected to torso
      function createArm(side, sideName) {
        const shoulder = new THREE.Group();
        shoulder.position.set(side * 0.3, 0.35, 0); // Relative to torso center
        shoulder.name = sideName + 'Shoulder';

        // Shoulder joint sphere (visible ball joint)
        const shoulderJoint = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 12), jointMaterial);
        shoulderJoint.castShadow = true;
        shoulder.add(shoulderJoint);

        // Upper arm - outer surface (lighter)
        const upperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.05, 0.4, 8), outerMaterial);
        upperArm.position.y = -0.2;
        upperArm.castShadow = true;
        shoulder.add(upperArm);

        // Upper arm - inner surface stripe (darker, toward body)
        const upperArmInner = new THREE.Mesh(
          new THREE.BoxGeometry(0.11, 0.4, 0.02),
          innerMaterial
        );
        upperArmInner.position.set(-side * 0.01, -0.2, 0);
        upperArmInner.castShadow = true;
        shoulder.add(upperArmInner);

        const elbow = new THREE.Group();
        elbow.position.y = -0.4;
        elbow.name = sideName + 'Elbow';

        // Elbow joint sphere (visible ball joint)
        const elbowJoint = new THREE.Mesh(new THREE.SphereGeometry(0.06, 12, 12), jointMaterial);
        elbowJoint.castShadow = true;
        elbow.add(elbowJoint);

        // Lower arm (forearm) - outer surface (back of hand side - lighter)
        const lowerArm = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.04, 0.4, 8), outerMaterial);
        lowerArm.position.y = -0.2;
        lowerArm.castShadow = true;
        elbow.add(lowerArm);

        // Lower arm - inner surface (palm side - darker)
        const lowerArmInner = new THREE.Mesh(
          new THREE.BoxGeometry(0.09, 0.4, 0.02),
          innerMaterial
        );
        lowerArmInner.position.set(0, -0.2, side * 0.01);
        lowerArmInner.castShadow = true;
        elbow.add(lowerArmInner);

        // Hand - back of hand (lighter) and palm (darker)
        const handOuter = new THREE.Mesh(new THREE.SphereGeometry(0.07, 8, 8), outerMaterial);
        handOuter.position.y = -0.4;
        handOuter.castShadow = true;
        elbow.add(handOuter);

        const handInner = new THREE.Mesh(
          new THREE.CircleGeometry(0.06, 8),
          innerMaterial
        );
        handInner.position.set(0, -0.4, side * 0.05);
        handInner.rotation.y = side * Math.PI / 2;
        handInner.castShadow = true;
        elbow.add(handInner);

        shoulder.add(elbow);
        return shoulder;
      }

      // Add arms to torso (not mannequin root)
      torsoGroup.add(createArm(-1, 'left'));
      torsoGroup.add(createArm(1, 'right'));

      // Legs - function to create leg connected to hips
      function createLeg(side, sideName) {
        const legGroup = new THREE.Group();
        legGroup.name = sideName + 'Leg';

        const hip = new THREE.Group();
        hip.position.set(side * 0.15, -0.15, 0); // Relative to hips center
        hip.name = sideName + 'Hip';

        // Hip joint sphere (visible ball joint)
        const hipJoint = new THREE.Mesh(new THREE.SphereGeometry(0.09, 12, 12), jointMaterial);
        hipJoint.castShadow = true;
        hip.add(hipJoint);

        // Upper leg (thigh) - outer surface (lighter)
        const upperLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.07, 0.6, 8), outerMaterial);
        upperLeg.position.y = -0.3;
        upperLeg.castShadow = true;
        hip.add(upperLeg);

        // Inner thigh (darker, toward groin)
        const innerThigh = new THREE.Mesh(
          new THREE.BoxGeometry(0.03, 0.6, 0.14),
          innerMaterial
        );
        innerThigh.position.set(-side * 0.05, -0.3, 0);
        innerThigh.castShadow = true;
        hip.add(innerThigh);

        const knee = new THREE.Group();
        knee.position.y = -0.6;
        knee.name = sideName + 'Knee';

        // Knee joint sphere (visible ball joint)
        const kneeJoint = new THREE.Mesh(new THREE.SphereGeometry(0.07, 12, 12), jointMaterial);
        kneeJoint.castShadow = true;
        knee.add(kneeJoint);

        // Lower leg (shin/calf) - outer surface (lighter)
        const lowerLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.05, 0.6, 8), outerMaterial);
        lowerLeg.position.y = -0.3;
        lowerLeg.castShadow = true;
        knee.add(lowerLeg);

        // Inner calf (darker)
        const innerCalf = new THREE.Mesh(
          new THREE.BoxGeometry(0.03, 0.6, 0.11),
          innerMaterial
        );
        innerCalf.position.set(-side * 0.04, -0.3, 0);
        innerCalf.castShadow = true;
        knee.add(innerCalf);

        // Foot - top (lighter) and sole (darker)
        const foot = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.25), outerMaterial);
        foot.position.y = -0.6;
        foot.position.z = 0.08;
        foot.castShadow = true;
        knee.add(foot);

        const footSole = new THREE.Mesh(
          new THREE.BoxGeometry(0.11, 0.02, 0.24),
          innerMaterial
        );
        footSole.position.set(0, -0.65, 0.08);
        footSole.castShadow = true;
        knee.add(footSole);

        hip.add(knee);
        legGroup.add(hip);
        return legGroup;
      }

      // Add legs to hips (not mannequin root)
      hipsGroup.add(createLeg(-1, 'left'));
      hipsGroup.add(createLeg(1, 'right'));

      return mannequin;
    }

    function selectFighter(fighter) {
      currentFighter = fighter;
      document.querySelectorAll('.fighter-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      loadPoseToUI(fighter === 'A' ? poseA : poseB);
    }

    function loadPoseToUI(pose) {
      document.getElementById('lean-fb').value = pose.leanForwardBack;
      document.getElementById('lean-lr').value = pose.leanLeftRight;
      document.getElementById('hip-rot').value = pose.hipRotation;
      document.getElementById('torso-rot').value = pose.torsoRotation;
      document.getElementById('neck-rot').value = pose.neckRotation;
      document.getElementById('l-shoulder-p').value = pose.leftShoulderPitch;
      document.getElementById('l-shoulder-r').value = pose.leftShoulderRoll;
      document.getElementById('l-shoulder-y').value = pose.leftShoulderYaw;
      document.getElementById('r-shoulder-p').value = pose.rightShoulderPitch;
      document.getElementById('r-shoulder-r').value = pose.rightShoulderRoll;
      document.getElementById('r-shoulder-y').value = pose.rightShoulderYaw;
      document.getElementById('l-elbow').value = pose.leftElbowBend;
      document.getElementById('r-elbow').value = pose.rightElbowBend;
      document.getElementById('l-hip-p').value = pose.leftHipPitch;
      document.getElementById('l-hip-r').value = pose.leftHipRoll;
      document.getElementById('l-hip-y').value = pose.leftHipYaw;
      document.getElementById('r-hip-p').value = pose.rightHipPitch;
      document.getElementById('r-hip-r').value = pose.rightHipRoll;
      document.getElementById('r-hip-y').value = pose.rightHipYaw;
      document.getElementById('l-knee').value = pose.leftKneeBend;
      document.getElementById('r-knee').value = pose.rightKneeBend;
      document.getElementById('stance').value = pose.stanceWidth;
      updatePose();
    }

    function readPoseFromUI() {
      return {
        leanForwardBack: parseFloat(document.getElementById('lean-fb').value),
        leanLeftRight: parseFloat(document.getElementById('lean-lr').value),
        hipRotation: parseFloat(document.getElementById('hip-rot').value),
        torsoRotation: parseFloat(document.getElementById('torso-rot').value),
        neckRotation: parseFloat(document.getElementById('neck-rot').value),
        leftShoulderPitch: parseFloat(document.getElementById('l-shoulder-p').value),
        leftShoulderRoll: parseFloat(document.getElementById('l-shoulder-r').value),
        leftShoulderYaw: parseFloat(document.getElementById('l-shoulder-y').value),
        rightShoulderPitch: parseFloat(document.getElementById('r-shoulder-p').value),
        rightShoulderRoll: parseFloat(document.getElementById('r-shoulder-r').value),
        rightShoulderYaw: parseFloat(document.getElementById('r-shoulder-y').value),
        leftElbowBend: parseFloat(document.getElementById('l-elbow').value),
        rightElbowBend: parseFloat(document.getElementById('r-elbow').value),
        leftHipPitch: parseFloat(document.getElementById('l-hip-p').value),
        leftHipRoll: parseFloat(document.getElementById('l-hip-r').value),
        leftHipYaw: parseFloat(document.getElementById('l-hip-y').value),
        rightHipPitch: parseFloat(document.getElementById('r-hip-p').value),
        rightHipRoll: parseFloat(document.getElementById('r-hip-r').value),
        rightHipYaw: parseFloat(document.getElementById('r-hip-y').value),
        leftKneeBend: parseFloat(document.getElementById('l-knee').value),
        rightKneeBend: parseFloat(document.getElementById('r-knee').value),
        stanceWidth: parseFloat(document.getElementById('stance').value)
      };
    }

    function updatePose() {
      const pose = readPoseFromUI();

      if (currentFighter === 'A') {
        poseA = pose;
      } else {
        poseB = pose;
      }

      // Update value displays
      document.getElementById('val-lean-fb').textContent = pose.leanForwardBack + 'Â°';
      document.getElementById('val-lean-lr').textContent = pose.leanLeftRight + 'Â°';
      document.getElementById('val-hip-rot').textContent = pose.hipRotation + 'Â°';
      document.getElementById('val-torso-rot').textContent = pose.torsoRotation + 'Â°';
      document.getElementById('val-neck-rot').textContent = pose.neckRotation + 'Â°';
      document.getElementById('val-l-shoulder-p').textContent = pose.leftShoulderPitch + 'Â°';
      document.getElementById('val-l-shoulder-r').textContent = pose.leftShoulderRoll + 'Â°';
      document.getElementById('val-l-shoulder-y').textContent = pose.leftShoulderYaw + 'Â°';
      document.getElementById('val-r-shoulder-p').textContent = pose.rightShoulderPitch + 'Â°';
      document.getElementById('val-r-shoulder-r').textContent = pose.rightShoulderRoll + 'Â°';
      document.getElementById('val-r-shoulder-y').textContent = pose.rightShoulderYaw + 'Â°';
      document.getElementById('val-l-elbow').textContent = pose.leftElbowBend + 'Â°';
      document.getElementById('val-r-elbow').textContent = pose.rightElbowBend + 'Â°';
      document.getElementById('val-l-hip-p').textContent = pose.leftHipPitch + 'Â°';
      document.getElementById('val-l-hip-r').textContent = pose.leftHipRoll + 'Â°';
      document.getElementById('val-l-hip-y').textContent = pose.leftHipYaw + 'Â°';
      document.getElementById('val-r-hip-p').textContent = pose.rightHipPitch + 'Â°';
      document.getElementById('val-r-hip-r').textContent = pose.rightHipRoll + 'Â°';
      document.getElementById('val-r-hip-y').textContent = pose.rightHipYaw + 'Â°';
      document.getElementById('val-l-knee').textContent = pose.leftKneeBend + 'Â°';
      document.getElementById('val-r-knee').textContent = pose.rightKneeBend + 'Â°';
      document.getElementById('val-stance').textContent = pose.stanceWidth + ' cm';

      // Apply poses
      resetMannequinPose(fighterA);
      resetMannequinPose(fighterB);
      poseMannequin(fighterA, poseA);
      poseMannequin(fighterB, poseB);

      // Update distance
      const distance = document.getElementById('distance').value;
      const distanceMap = { 'c': 1.5, 's': 2.5, 'm': 4, 'l': 6, 'v': 8 };
      const dist = distanceMap[distance];
      fighterA.position.x = -dist / 2;
      fighterB.position.x = dist / 2;

      // Update MPN output
      updateMPNOutput();
    }

    function updateMPNOutput() {
      const distance = document.getElementById('distance').value;
      const mpnA = poseToMPN(poseA);
      const mpnB = poseToMPN(poseB);
      document.getElementById('mpn-output').textContent = `${mpnA}/${mpnB}/${distance}`;
    }

    function poseToMPN(pose) {
      return `${pose.leanForwardBack},${pose.leanLeftRight}.${pose.hipRotation},${pose.torsoRotation},${pose.neckRotation}.${pose.leftShoulderPitch},${pose.leftShoulderRoll},${pose.leftShoulderYaw},${pose.rightShoulderPitch},${pose.rightShoulderRoll},${pose.rightShoulderYaw}.${pose.leftElbowBend},${pose.rightElbowBend}.${pose.leftHipPitch},${pose.leftHipRoll},${pose.leftHipYaw},${pose.rightHipPitch},${pose.rightHipRoll},${pose.rightHipYaw}.${pose.leftKneeBend},${pose.rightKneeBend}.${pose.stanceWidth},90`;
    }

    function resetMannequinPose(mannequin) {
      mannequin.rotation.set(0, mannequin.rotation.y, 0);
      mannequin.traverse((obj) => {
        if (obj.isGroup || obj.isMesh) {
          if (obj.name !== 'leftLeg' && obj.name !== 'rightLeg') {
            obj.rotation.set(0, 0, 0);
          }
        }
      });

      const leftLeg = mannequin.getObjectByName('leftLeg');
      const rightLeg = mannequin.getObjectByName('rightLeg');
      if (leftLeg) leftLeg.position.x = 0;
      if (rightLeg) rightLeg.position.x = 0;
    }

    function calculateLegBiomechanics(stanceWidthCm) {
      // Calculate proper leg angles based on biomechanics
      // Stance width determines hip ABDUCTION angle (legs spreading sideways)
      // The hip is a ball-and-socket joint at the pelvis

      const stanceM = stanceWidthCm / 100.0; // Convert to meters
      const hipWidth = 0.30; // Hip joint separation (30cm) - FIXED at pelvis
      const thighLength = 0.45; // Thigh length (45cm)
      const shinLength = 0.45; // Shin length (45cm)
      const totalLegLength = thighLength + shinLength;

      // Desired foot separation from stance width
      const desiredFootSeparation = stanceM;

      // Hip joints are fixed at Â±15cm (hip width / 2)
      // To achieve desired foot separation, calculate required hip abduction angle
      const hipJointSeparation = hipWidth;
      const additionalSpread = desiredFootSeparation - hipJointSeparation;

      // Hip abduction angle needed to spread feet to desired width
      // tan(abduction_angle) = (additional_spread/2) / leg_length
      const abductionAngle = Math.atan((additionalSpread / 2) / totalLegLength);
      const abductionDeg = THREE.MathUtils.radToDeg(abductionAngle);

      // Calculate knee bend: as legs angle out, knees must bend to keep feet on ground
      const baseKneeBend = 15; // Minimum bend even in narrow stance
      const additionalBend = abductionDeg * 1.5; // More bend as legs angle out
      const kneeBend = baseKneeBend + additionalBend;

      return {
        kneeBend: Math.min(kneeBend, 60), // Cap at 60Â° for realistic squat
        hipAbduction: Math.min(Math.abs(abductionDeg), 35), // Cap abduction at 35Â°
        legAngle: abductionDeg
      };
    }

    function poseMannequin(mannequin, pose) {
      // Torso angle from hips - lean is now in degrees, not cm
      const hips = mannequin.getObjectByName('hips');
      const torso = mannequin.getObjectByName('torso');
      const neck = mannequin.getObjectByName('neck');
      const head = mannequin.getObjectByName('head');

      // Convert lean angles to radians
      // rotation.x = forward/back lean (pitch around x-axis)
      // rotation.z = left/right lean (roll around z-axis)
      const leanFBRad = THREE.MathUtils.degToRad(pose.leanForwardBack);
      const leanLRRad = THREE.MathUtils.degToRad(pose.leanLeftRight);

      // Torso gets the full lean angle (torso angle from hip)
      if (torso) {
        torso.rotation.x = leanFBRad;  // Forward/back
        torso.rotation.z = leanLRRad;  // Left/right
        torso.rotation.y = THREE.MathUtils.degToRad(pose.torsoRotation);
      }

      // Hips rotation (pelvis twist) - but keep feet planted!
      if (hips) {
        hips.rotation.y = THREE.MathUtils.degToRad(pose.hipRotation);

        // Counter-rotate the legs to keep feet planted on the ground
        const lLeg = mannequin.getObjectByName('leftLeg');
        const rLeg = mannequin.getObjectByName('rightLeg');
        if (lLeg) lLeg.rotation.y = -THREE.MathUtils.degToRad(pose.hipRotation);
        if (rLeg) rLeg.rotation.y = -THREE.MathUtils.degToRad(pose.hipRotation);
      }

      if (neck) neck.rotation.y = THREE.MathUtils.degToRad(pose.neckRotation);
      if (head) head.rotation.y = THREE.MathUtils.degToRad(pose.neckRotation);

      // Shoulders (3DOF ball-and-socket joint)
      const lShoulder = mannequin.getObjectByName('leftShoulder');
      const rShoulder = mannequin.getObjectByName('rightShoulder');

      if (lShoulder) {
        lShoulder.rotation.order = 'YXZ';  // Yaw-Pitch-Roll order for proper shoulder mechanics
        lShoulder.rotation.x = THREE.MathUtils.degToRad(-pose.leftShoulderPitch);  // Pitch: up/down
        lShoulder.rotation.z = THREE.MathUtils.degToRad(-pose.leftShoulderRoll);   // Roll: arm spreads outward
        lShoulder.rotation.y = THREE.MathUtils.degToRad(pose.leftShoulderYaw);     // Yaw: internal/external rotation (hooks!)
      }

      if (rShoulder) {
        rShoulder.rotation.order = 'YXZ';  // Yaw-Pitch-Roll order for proper shoulder mechanics
        rShoulder.rotation.x = THREE.MathUtils.degToRad(-pose.rightShoulderPitch);
        rShoulder.rotation.z = THREE.MathUtils.degToRad(pose.rightShoulderRoll);
        rShoulder.rotation.y = THREE.MathUtils.degToRad(pose.rightShoulderYaw);    // Yaw: internal/external rotation (hooks!)
      }

      // Elbows (negative because elbow bends bring forearm UP/back, not down)
      const lElbow = mannequin.getObjectByName('leftElbow');
      const rElbow = mannequin.getObjectByName('rightElbow');

      if (lElbow) lElbow.rotation.x = THREE.MathUtils.degToRad(-pose.leftElbowBend);
      if (rElbow) rElbow.rotation.x = THREE.MathUtils.degToRad(-pose.rightElbowBend);

      // Hips and Knees - calculate biomechanically correct angles from stance width
      const lHip = mannequin.getObjectByName('leftHip');
      const rHip = mannequin.getObjectByName('rightHip');
      const lKnee = mannequin.getObjectByName('leftKnee');
      const rKnee = mannequin.getObjectByName('rightKnee');

      // Calculate biomechanics from stance width
      const legBio = calculateLegBiomechanics(pose.stanceWidth);

      // Hip ABDUCTION (Z-axis): spreading legs sideways for stance width
      // Hip PITCH (X-axis): lifting leg forward/back for kicks
      // Hip ROTATION (Y-axis): rotating leg inward/outward for round kicks

      // For stance: use calculated abduction angle from biomechanics
      // For kicks: use explicit pitch/roll angles
      const isLeftKicking = pose.leftHipPitch > 30;  // Threshold for kick
      const isRightKicking = pose.rightHipPitch > 30;

      if (lHip) {
        lHip.rotation.order = 'YXZ';  // Yaw-Pitch-Roll order for proper hip mechanics

        // X-axis pitch: forward/back (kicks)
        lHip.rotation.x = THREE.MathUtils.degToRad(-pose.leftHipPitch);

        // Z-axis abduction: spreading legs sideways
        // Use biomechanical abduction for stance, or explicit angle for special moves
        const leftAbduction = isLeftKicking ? pose.leftHipRoll : legBio.hipAbduction;
        lHip.rotation.z = THREE.MathUtils.degToRad(-leftAbduction);  // Negative = outward

        // Y-axis yaw: leg rotation inward/outward (CRITICAL for round kicks!)
        lHip.rotation.y = THREE.MathUtils.degToRad(pose.leftHipYaw);
      }

      if (rHip) {
        rHip.rotation.order = 'YXZ';  // Yaw-Pitch-Roll order for proper hip mechanics

        rHip.rotation.x = THREE.MathUtils.degToRad(-pose.rightHipPitch);

        const rightAbduction = isRightKicking ? pose.rightHipRoll : legBio.hipAbduction;
        rHip.rotation.z = THREE.MathUtils.degToRad(rightAbduction);  // Positive = outward

        // Y-axis yaw: leg rotation inward/outward (CRITICAL for round kicks!)
        rHip.rotation.y = THREE.MathUtils.degToRad(pose.rightHipYaw);
      }

      // Apply knee bend - use biomechanically calculated bend unless overridden
      // (for kicks, explicit knee bend is set, otherwise use calculated from stance)
      const leftKneeFinal = pose.leftKneeBend !== 15 ? pose.leftKneeBend : legBio.kneeBend;
      const rightKneeFinal = pose.rightKneeBend !== 15 ? pose.rightKneeBend : legBio.kneeBend;

      // NOTE: Swapped because controls were reversed
      if (lKnee) lKnee.rotation.x = THREE.MathUtils.degToRad(rightKneeFinal);
      if (rKnee) rKnee.rotation.x = THREE.MathUtils.degToRad(leftKneeFinal);

      // NOTE: Leg positions are FIXED at hip socket locations (Â±15cm from center)
      // Stance width is controlled by HIP ROTATION (abduction), not by moving the legs!
      // The hip is a ball-and-socket joint that rotates to angle the leg outward
    }

    function resetPose() {
      if (currentFighter === 'A') {
        poseA = createNeutralPose();
        loadPoseToUI(poseA);
      } else {
        poseB = createNeutralPose();
        loadPoseToUI(poseB);
      }
    }

    function resetBoth() {
      poseA = createNeutralPose();
      poseB = createNeutralPose();
      loadPoseToUI(currentFighter === 'A' ? poseA : poseB);
    }

    function randomPose() {
      // Generate more realistic martial arts poses with constrained ranges
      const isKicking = Math.random() > 0.7; // 30% chance of kick pose
      const isPunching = !isKicking && Math.random() > 0.5; // 35% chance of punch

      let leftHipPitch = 0, rightHipPitch = 0;
      let leftHipYaw = 0, rightHipYaw = 0;
      let leftKneeBend = 15, rightKneeBend = 15;

      // Generate kick if applicable
      if (isKicking) {
        const kickingSide = Math.random() > 0.5 ? 'left' : 'right';
        const kickHeight = Math.floor(30 + Math.random() * 120); // 30-150 degrees
        const isRoundKick = Math.random() > 0.5;

        if (kickingSide === 'left') {
          leftHipPitch = kickHeight;
          leftKneeBend = Math.floor(5 + Math.random() * 30); // Extended leg
          leftHipYaw = isRoundKick ? Math.floor(-30 - Math.random() * 40) : 0;
          rightKneeBend = Math.floor(15 + Math.random() * 20); // Standing leg
        } else {
          rightHipPitch = kickHeight;
          rightKneeBend = Math.floor(5 + Math.random() * 30);
          rightHipYaw = isRoundKick ? Math.floor(-30 - Math.random() * 40) : 0;
          leftKneeBend = Math.floor(15 + Math.random() * 20);
        }
      } else {
        // Regular stance
        leftKneeBend = Math.floor(10 + Math.random() * 30);
        rightKneeBend = Math.floor(10 + Math.random() * 30);
      }

      const pose = {
        leanForwardBack: Math.floor(-10 + Math.random() * 35), // -10 to 25 (slight forward lean)
        leanLeftRight: Math.floor((Math.random() - 0.5) * 30), // -15 to 15
        hipRotation: Math.floor((Math.random() - 0.5) * 60), // -30 to 30
        torsoRotation: Math.floor((Math.random() - 0.5) * 60), // -30 to 30
        neckRotation: Math.floor((Math.random() - 0.5) * 50), // -25 to 25

        // Arm positions - more constrained for realistic guard/punch positions
        leftShoulderPitch: isPunching && Math.random() > 0.5 ?
          Math.floor(30 + Math.random() * 40) : Math.floor(-20 + Math.random() * 80),
        leftShoulderRoll: Math.floor(Math.random() * 60), // 0-60 (not too high)
        leftShoulderYaw: Math.floor(-40 + Math.random() * 80), // -40 to 40

        rightShoulderPitch: isPunching && Math.random() > 0.5 ?
          Math.floor(30 + Math.random() * 40) : Math.floor(-20 + Math.random() * 80),
        rightShoulderRoll: Math.floor(Math.random() * 60),
        rightShoulderYaw: Math.floor(10 + Math.random() * 50), // 10-60 (rear guard bias)

        leftElbowBend: Math.floor(60 + Math.random() * 70), // 60-130 (keep bent)
        rightElbowBend: Math.floor(60 + Math.random() * 70),

        // Leg positions
        leftHipPitch: leftHipPitch,
        leftHipRoll: Math.floor((Math.random() - 0.5) * 20), // -10 to 10
        leftHipYaw: leftHipYaw,

        rightHipPitch: rightHipPitch,
        rightHipRoll: Math.floor((Math.random() - 0.5) * 20),
        rightHipYaw: rightHipYaw,

        leftKneeBend: leftKneeBend,
        rightKneeBend: rightKneeBend,

        stanceWidth: Math.floor(30 + Math.random() * 35) // 30-65cm
      };

      if (currentFighter === 'A') {
        poseA = pose;
      } else {
        poseB = pose;
      }
      loadPoseToUI(pose);
    }

    function loadPreset(preset) {
      let pose;
      switch(preset) {
        case 'neutral':
          pose = createNeutralPose();
          break;
        case 'jab':
          pose = {
            ...createNeutralPose(),
            leanForwardBack: 8,
            hipRotation: 10,
            torsoRotation: 15,
            leftShoulderPitch: 45,
            leftShoulderRoll: 0,
            leftElbowBend: 20,
            rightShoulderPitch: -20,
            rightShoulderRoll: 30
          };
          break;
        case 'guard':
          pose = {
            ...createNeutralPose(),
            leftShoulderPitch: 60,
            leftShoulderRoll: 20,
            rightShoulderPitch: 60,
            rightShoulderRoll: 20,
            leftElbowBend: 100,
            rightElbowBend: 100
          };
          break;
        case 'kick':
          pose = {
            ...createNeutralPose(),
            leanForwardBack: -5,
            hipRotation: 15,
            torsoRotation: -10,
            rightHipPitch: 90,
            rightKneeBend: 30,
            leftKneeBend: 25,
            stanceWidth: 25
          };
          break;
        case 'highkick':
          pose = {
            ...createNeutralPose(),
            leanForwardBack: -25, // Lean torso backward
            hipRotation: 60, // Heavy hip rotation for round kick
            torsoRotation: 30, // Torso counters
            rightHipPitch: 170, // High kick to head level
            rightHipRoll: 45, // Leg abducted to side
            rightHipYaw: -60, // Leg rotates inward - ROUND KICK!
            rightKneeBend: 15, // Nearly extended leg
            leftKneeBend: 20, // Standing leg slightly bent
            leftHipPitch: -10, // Standing leg stable
            stanceWidth: 30
          };
          break;
        case 'hook':
          pose = {
            ...createNeutralPose(),
            leanForwardBack: 5,
            leanLeftRight: -10, // Lean to load hook
            hipRotation: -25, // Hip rotates into punch
            torsoRotation: -30, // Torso winds up
            leftShoulderPitch: 0, // Shoulder stays level (not up)
            leftShoulderRoll: 45, // Arm spreads wide to side
            leftShoulderYaw: -70, // INTERNAL ROTATION - elbow points forward for hook!
            leftElbowBend: 90, // Classic 90Â° bent arm hook
            rightShoulderPitch: -10,
            rightShoulderRoll: 20,
            rightShoulderYaw: 45 // Rear hand stays tucked
          };
          break;
      }

      if (currentFighter === 'A') {
        poseA = pose;
      } else {
        poseB = pose;
      }
      loadPoseToUI(pose);
    }

    // Mouse controls
    let mouseDown = false;
    let mouseX = 0, mouseY = 0;
    let cameraAngle = 0;
    let cameraHeight = 2;
    let cameraDistance = 6;

    function setupMouseControls() {
      const container = document.getElementById('canvas-container');

      container.addEventListener('mousedown', (e) => {
        mouseDown = true;
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      container.addEventListener('mouseup', () => {
        mouseDown = false;
      });

      container.addEventListener('mousemove', (e) => {
        if (!mouseDown) return;

        const deltaX = e.clientX - mouseX;
        const deltaY = e.clientY - mouseY;

        cameraAngle += deltaX * 0.01;
        cameraHeight = Math.max(0.5, Math.min(5, cameraHeight - deltaY * 0.01));

        mouseX = e.clientX;
        mouseY = e.clientY;

        updateCamera();
      });

      container.addEventListener('wheel', (e) => {
        e.preventDefault();
        cameraDistance = Math.max(2, Math.min(12, cameraDistance + e.deltaY * 0.01));
        updateCamera();
      });
    }

    function updateCamera() {
      camera.position.x = Math.sin(cameraAngle) * cameraDistance;
      camera.position.z = Math.cos(cameraAngle) * cameraDistance;
      camera.position.y = cameraHeight;
      camera.lookAt(0, 2, 0);
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const container = document.getElementById('canvas-container');
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }

    // Initialize
    init();
  </script>
</body>
</html>
