<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>MPN 3D Mannequin Viewer</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #2a2a2a;
      display: flex;
    }

    #controls {
      width: 380px;
      height: 100vh;
      overflow-y: auto;
      background: rgba(255,255,255,0.95);
      padding: 20px;
      box-shadow: 2px 0 8px rgba(0,0,0,0.3);
    }

    #canvas-container {
      flex: 1;
      height: 100vh;
    }

    h2 {
      margin: 0 0 15px 0;
      font-size: 18px;
    }

    h3 {
      margin: 20px 0 10px 0;
      font-size: 14px;
      color: #333;
      border-bottom: 2px solid #4CAF50;
      padding-bottom: 5px;
    }

    .fighter-select {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .fighter-btn {
      flex: 1;
      padding: 10px;
      border: 2px solid #ddd;
      background: white;
      cursor: pointer;
      border-radius: 4px;
      font-weight: bold;
    }

    .fighter-btn.active {
      border-color: #4CAF50;
      background: #e8f5e9;
    }

    .slider-group {
      margin-bottom: 15px;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      margin-bottom: 3px;
      color: #555;
    }

    .slider-value {
      font-weight: bold;
      color: #4CAF50;
    }

    input[type="range"] {
      width: 100%;
      margin: 5px 0;
    }

    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 16px;
      font-size: 13px;
      border-radius: 4px;
      cursor: pointer;
      width: 100%;
      margin-top: 10px;
    }

    button:hover {
      background: #45a049;
    }

    .example-btn {
      background: #2196F3;
      font-size: 11px;
      padding: 8px;
      margin-top: 5px;
    }

    .example-btn:hover {
      background: #0b7dda;
    }

    .distance-select {
      width: 100%;
      padding: 8px;
      margin-top: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .info {
      font-size: 11px;
      color: #666;
      background: #f5f5f5;
      padding: 8px;
      border-radius: 4px;
      margin-top: 10px;
    }

    #mpn-output {
      font-family: monospace;
      font-size: 10px;
      background: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
      word-break: break-all;
      max-height: 100px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div id="controls">
    <h2>ðŸ¥‹ Mannequin Pose Editor</h2>

    <div class="fighter-select">
      <button class="fighter-btn active" onclick="selectFighter('A')">Fighter A (Red)</button>
      <button class="fighter-btn" onclick="selectFighter('B')">Fighter B (Blue)</button>
    </div>

    <h3>Body Position</h3>
    <div class="slider-group">
      <div class="slider-label">
        <span>Torso Lean Forward/Back (from hip)</span>
        <span class="slider-value" id="val-lean-fb">0Â°</span>
      </div>
      <input type="range" id="lean-fb" min="-45" max="45" value="0" step="1" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Torso Lean Left/Right (from hip)</span>
        <span class="slider-value" id="val-lean-lr">0Â°</span>
      </div>
      <input type="range" id="lean-lr" min="-45" max="45" value="0" step="1" oninput="updatePose()">
    </div>

    <h3>Torso Rotation</h3>
    <div class="slider-group">
      <div class="slider-label">
        <span>Hip Rotation</span>
        <span class="slider-value" id="val-hip-rot">0Â°</span>
      </div>
      <input type="range" id="hip-rot" min="-45" max="45" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Torso Rotation (relative to hips)</span>
        <span class="slider-value" id="val-torso-rot">0Â°</span>
      </div>
      <input type="range" id="torso-rot" min="-45" max="45" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Neck/Head Turn</span>
        <span class="slider-value" id="val-neck-rot">0Â°</span>
      </div>
      <input type="range" id="neck-rot" min="-60" max="60" value="0" step="5" oninput="updatePose()">
    </div>

    <h3>Arms</h3>
    <div class="slider-group">
      <div class="slider-label">
        <span>Left Shoulder Pitch (forward/up)</span>
        <span class="slider-value" id="val-l-shoulder-p">0Â°</span>
      </div>
      <input type="range" id="l-shoulder-p" min="-60" max="180" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Left Shoulder Roll (raise sideways)</span>
        <span class="slider-value" id="val-l-shoulder-r">0Â°</span>
      </div>
      <input type="range" id="l-shoulder-r" min="0" max="180" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Left Elbow Bend</span>
        <span class="slider-value" id="val-l-elbow">90Â°</span>
      </div>
      <input type="range" id="l-elbow" min="0" max="150" value="90" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Right Shoulder Pitch (forward/up)</span>
        <span class="slider-value" id="val-r-shoulder-p">0Â°</span>
      </div>
      <input type="range" id="r-shoulder-p" min="-60" max="180" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Right Shoulder Roll (raise sideways)</span>
        <span class="slider-value" id="val-r-shoulder-r">0Â°</span>
      </div>
      <input type="range" id="r-shoulder-r" min="0" max="180" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Right Elbow Bend</span>
        <span class="slider-value" id="val-r-elbow">90Â°</span>
      </div>
      <input type="range" id="r-elbow" min="0" max="150" value="90" step="5" oninput="updatePose()">
    </div>

    <h3>Legs</h3>
    <div class="slider-group">
      <div class="slider-label">
        <span>Left Hip Pitch (kick forward/back)</span>
        <span class="slider-value" id="val-l-hip-p">0Â°</span>
      </div>
      <input type="range" id="l-hip-p" min="-30" max="200" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Left Hip Roll (sideways)</span>
        <span class="slider-value" id="val-l-hip-r">0Â°</span>
      </div>
      <input type="range" id="l-hip-r" min="-45" max="45" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Left Knee Bend</span>
        <span class="slider-value" id="val-l-knee">15Â°</span>
      </div>
      <input type="range" id="l-knee" min="0" max="140" value="15" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Right Hip Pitch (kick forward/back)</span>
        <span class="slider-value" id="val-r-hip-p">0Â°</span>
      </div>
      <input type="range" id="r-hip-p" min="-30" max="200" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Right Hip Roll (sideways)</span>
        <span class="slider-value" id="val-r-hip-r">0Â°</span>
      </div>
      <input type="range" id="r-hip-r" min="-45" max="45" value="0" step="5" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Right Knee Bend</span>
        <span class="slider-value" id="val-r-knee">15Â°</span>
      </div>
      <input type="range" id="r-knee" min="0" max="140" value="15" step="5" oninput="updatePose()">
    </div>

    <h3>Stance</h3>
    <div class="slider-group">
      <div class="slider-label">
        <span>Stance Width</span>
        <span class="slider-value" id="val-stance">40 cm</span>
      </div>
      <input type="range" id="stance" min="20" max="80" value="40" step="2" oninput="updatePose()">
    </div>

    <div class="slider-group">
      <div class="slider-label">
        <span>Distance Between Fighters</span>
      </div>
      <select class="distance-select" id="distance" onchange="updatePose()">
        <option value="c">Contact (1.5m)</option>
        <option value="s">Short (2.5m)</option>
        <option value="m" selected>Medium (4m)</option>
        <option value="l">Long (6m)</option>
        <option value="v">Very Long (8m)</option>
      </select>
    </div>

    <button onclick="resetPose()">Reset Current Fighter</button>
    <button onclick="resetBoth()">Reset Both Fighters</button>
    <button onclick="randomPose()" style="background: #FF9800;">ðŸŽ² Random Pose</button>

    <h3>Preset Poses</h3>
    <button class="example-btn" onclick="loadPreset('neutral')">Neutral Stance</button>
    <button class="example-btn" onclick="loadPreset('jab')">Jab</button>
    <button class="example-btn" onclick="loadPreset('guard')">Guard Position</button>
    <button class="example-btn" onclick="loadPreset('kick')">Front Kick</button>
    <button class="example-btn" onclick="loadPreset('highkick')">High Kick to Head</button>

    <div class="info">
      <strong>MPN Output:</strong>
      <div id="mpn-output"></div>
    </div>
  </div>

  <div id="canvas-container"></div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // State
    let scene, camera, renderer;
    let fighterA, fighterB;
    let currentFighter = 'A';

    // Pose data for both fighters
    let poseA = createNeutralPose();
    let poseB = createNeutralPose();

    function createNeutralPose() {
      return {
        leanForwardBack: 0,
        leanLeftRight: 0,
        hipRotation: 0,
        torsoRotation: 0,
        neckRotation: 0,
        leftShoulderPitch: 0,
        leftShoulderRoll: 0,
        rightShoulderPitch: 0,
        rightShoulderRoll: 0,
        leftElbowBend: 90,
        rightElbowBend: 90,
        leftHipPitch: 0,
        leftHipRoll: 0,
        rightHipPitch: 0,
        rightHipRoll: 0,
        leftKneeBend: 15,
        rightKneeBend: 15,
        stanceWidth: 40
      };
    }

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x2a2a2a);

      // Camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 6);
      camera.lookAt(0, 2, 0);

      // Renderer
      const container = document.getElementById('canvas-container');
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
      mainLight.position.set(5, 10, 5);
      mainLight.castShadow = true;
      scene.add(mainLight);

      // Ground
      const groundGeometry = new THREE.PlaneGeometry(20, 20);
      const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
      const groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
      groundPlane.rotation.x = -Math.PI / 2;
      groundPlane.receiveShadow = true;
      scene.add(groundPlane);

      const gridHelper = new THREE.GridHelper(20, 20, 0x666666, 0x333333);
      scene.add(gridHelper);

      // Create mannequins
      fighterA = createMannequin(0xff4444);
      fighterB = createMannequin(0x4444ff);

      fighterA.position.set(-2, 0, 0);
      fighterB.position.set(2, 0, 0);
      fighterA.rotation.y = -Math.PI / 2; // Face toward +X (toward B)
      fighterB.rotation.y = Math.PI / 2;  // Face toward -X (toward A)

      scene.add(fighterA);
      scene.add(fighterB);

      // Mouse controls
      setupMouseControls();

      // Initial update
      updatePose();

      // Render loop
      animate();

      window.addEventListener('resize', onWindowResize);
    }

    function createMannequin(color) {
      const mannequin = new THREE.Group();
      const material = new THREE.MeshStandardMaterial({ color, roughness: 0.5, metalness: 0.3 });

      // Build from ground up using forward kinematics
      // Root is at ground level (y=0)

      // Hips - the root of the kinematic chain (connected to ground)
      const hipsGroup = new THREE.Group();
      hipsGroup.position.y = 1.05; // Height from ground to hip joint
      hipsGroup.name = 'hips';

      const hipsMesh = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.3, 0.3), material);
      hipsMesh.castShadow = true;
      hipsGroup.add(hipsMesh);

      mannequin.add(hipsGroup);

      // Torso - connected to hips
      const torsoGroup = new THREE.Group();
      torsoGroup.position.y = 0.55; // Distance from hip center to torso center
      torsoGroup.name = 'torso';

      const torsoMesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.8, 0.3), material);
      torsoMesh.castShadow = true;
      torsoGroup.add(torsoMesh);

      hipsGroup.add(torsoGroup); // Torso is child of hips

      // Neck - connected to top of torso
      const neckGroup = new THREE.Group();
      neckGroup.position.y = 0.475; // From torso center to neck base
      neckGroup.name = 'neck';

      const neckMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.15, 8), material);
      neckMesh.position.y = 0.075; // Neck mesh offset
      neckMesh.castShadow = true;
      neckGroup.add(neckMesh);

      torsoGroup.add(neckGroup); // Neck is child of torso

      // Head - connected to neck
      const headGroup = new THREE.Group();
      headGroup.position.y = 0.15; // From neck base to head center
      headGroup.name = 'head';

      const headMesh = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), material);
      headMesh.position.y = 0.2; // Head mesh offset
      headMesh.castShadow = true;
      headGroup.add(headMesh);

      // Nose - cone pointing forward to show orientation
      const noseMaterial = new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.5,
        metalness: 0.3
      });
      const noseGeometry = new THREE.ConeGeometry(0.04, 0.12, 8);
      const noseMesh = new THREE.Mesh(noseGeometry, noseMaterial);
      noseMesh.position.set(0, 0.2, 0.16); // Stick out from front of head
      noseMesh.rotation.x = Math.PI / 2; // Point forward
      noseMesh.castShadow = true;
      headGroup.add(noseMesh);

      neckGroup.add(headGroup); // Head is child of neck

      // Arms - function to create arm connected to torso
      function createArm(side, sideName) {
        const shoulder = new THREE.Group();
        shoulder.position.set(side * 0.3, 0.35, 0); // Relative to torso center
        shoulder.name = sideName + 'Shoulder';

        const upperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.05, 0.4, 8), material);
        upperArm.position.y = -0.2;
        upperArm.castShadow = true;
        shoulder.add(upperArm);

        const elbow = new THREE.Group();
        elbow.position.y = -0.4;
        elbow.name = sideName + 'Elbow';

        const lowerArm = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.04, 0.4, 8), material);
        lowerArm.position.y = -0.2;
        lowerArm.castShadow = true;
        elbow.add(lowerArm);

        const hand = new THREE.Mesh(new THREE.SphereGeometry(0.07, 8, 8), material);
        hand.position.y = -0.4;
        hand.castShadow = true;
        elbow.add(hand);

        shoulder.add(elbow);
        return shoulder;
      }

      // Add arms to torso (not mannequin root)
      torsoGroup.add(createArm(-1, 'left'));
      torsoGroup.add(createArm(1, 'right'));

      // Legs - function to create leg connected to hips
      function createLeg(side, sideName) {
        const legGroup = new THREE.Group();
        legGroup.name = sideName + 'Leg';

        const hip = new THREE.Group();
        hip.position.set(side * 0.15, -0.15, 0); // Relative to hips center
        hip.name = sideName + 'Hip';

        const upperLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.07, 0.6, 8), material);
        upperLeg.position.y = -0.3;
        upperLeg.castShadow = true;
        hip.add(upperLeg);

        const knee = new THREE.Group();
        knee.position.y = -0.6;
        knee.name = sideName + 'Knee';

        const lowerLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.05, 0.6, 8), material);
        lowerLeg.position.y = -0.3;
        lowerLeg.castShadow = true;
        knee.add(lowerLeg);

        const foot = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.25), material);
        foot.position.y = -0.6;
        foot.position.z = 0.08;
        foot.castShadow = true;
        knee.add(foot);

        hip.add(knee);
        legGroup.add(hip);
        return legGroup;
      }

      // Add legs to hips (not mannequin root)
      hipsGroup.add(createLeg(-1, 'left'));
      hipsGroup.add(createLeg(1, 'right'));

      return mannequin;
    }

    function selectFighter(fighter) {
      currentFighter = fighter;
      document.querySelectorAll('.fighter-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      loadPoseToUI(fighter === 'A' ? poseA : poseB);
    }

    function loadPoseToUI(pose) {
      document.getElementById('lean-fb').value = pose.leanForwardBack;
      document.getElementById('lean-lr').value = pose.leanLeftRight;
      document.getElementById('hip-rot').value = pose.hipRotation;
      document.getElementById('torso-rot').value = pose.torsoRotation;
      document.getElementById('neck-rot').value = pose.neckRotation;
      document.getElementById('l-shoulder-p').value = pose.leftShoulderPitch;
      document.getElementById('l-shoulder-r').value = pose.leftShoulderRoll;
      document.getElementById('r-shoulder-p').value = pose.rightShoulderPitch;
      document.getElementById('r-shoulder-r').value = pose.rightShoulderRoll;
      document.getElementById('l-elbow').value = pose.leftElbowBend;
      document.getElementById('r-elbow').value = pose.rightElbowBend;
      document.getElementById('l-hip-p').value = pose.leftHipPitch;
      document.getElementById('l-hip-r').value = pose.leftHipRoll;
      document.getElementById('r-hip-p').value = pose.rightHipPitch;
      document.getElementById('r-hip-r').value = pose.rightHipRoll;
      document.getElementById('l-knee').value = pose.leftKneeBend;
      document.getElementById('r-knee').value = pose.rightKneeBend;
      document.getElementById('stance').value = pose.stanceWidth;
      updatePose();
    }

    function readPoseFromUI() {
      return {
        leanForwardBack: parseFloat(document.getElementById('lean-fb').value),
        leanLeftRight: parseFloat(document.getElementById('lean-lr').value),
        hipRotation: parseFloat(document.getElementById('hip-rot').value),
        torsoRotation: parseFloat(document.getElementById('torso-rot').value),
        neckRotation: parseFloat(document.getElementById('neck-rot').value),
        leftShoulderPitch: parseFloat(document.getElementById('l-shoulder-p').value),
        leftShoulderRoll: parseFloat(document.getElementById('l-shoulder-r').value),
        rightShoulderPitch: parseFloat(document.getElementById('r-shoulder-p').value),
        rightShoulderRoll: parseFloat(document.getElementById('r-shoulder-r').value),
        leftElbowBend: parseFloat(document.getElementById('l-elbow').value),
        rightElbowBend: parseFloat(document.getElementById('r-elbow').value),
        leftHipPitch: parseFloat(document.getElementById('l-hip-p').value),
        leftHipRoll: parseFloat(document.getElementById('l-hip-r').value),
        rightHipPitch: parseFloat(document.getElementById('r-hip-p').value),
        rightHipRoll: parseFloat(document.getElementById('r-hip-r').value),
        leftKneeBend: parseFloat(document.getElementById('l-knee').value),
        rightKneeBend: parseFloat(document.getElementById('r-knee').value),
        stanceWidth: parseFloat(document.getElementById('stance').value)
      };
    }

    function updatePose() {
      const pose = readPoseFromUI();

      if (currentFighter === 'A') {
        poseA = pose;
      } else {
        poseB = pose;
      }

      // Update value displays
      document.getElementById('val-lean-fb').textContent = pose.leanForwardBack + 'Â°';
      document.getElementById('val-lean-lr').textContent = pose.leanLeftRight + 'Â°';
      document.getElementById('val-hip-rot').textContent = pose.hipRotation + 'Â°';
      document.getElementById('val-torso-rot').textContent = pose.torsoRotation + 'Â°';
      document.getElementById('val-neck-rot').textContent = pose.neckRotation + 'Â°';
      document.getElementById('val-l-shoulder-p').textContent = pose.leftShoulderPitch + 'Â°';
      document.getElementById('val-l-shoulder-r').textContent = pose.leftShoulderRoll + 'Â°';
      document.getElementById('val-r-shoulder-p').textContent = pose.rightShoulderPitch + 'Â°';
      document.getElementById('val-r-shoulder-r').textContent = pose.rightShoulderRoll + 'Â°';
      document.getElementById('val-l-elbow').textContent = pose.leftElbowBend + 'Â°';
      document.getElementById('val-r-elbow').textContent = pose.rightElbowBend + 'Â°';
      document.getElementById('val-l-hip-p').textContent = pose.leftHipPitch + 'Â°';
      document.getElementById('val-l-hip-r').textContent = pose.leftHipRoll + 'Â°';
      document.getElementById('val-r-hip-p').textContent = pose.rightHipPitch + 'Â°';
      document.getElementById('val-r-hip-r').textContent = pose.rightHipRoll + 'Â°';
      document.getElementById('val-l-knee').textContent = pose.leftKneeBend + 'Â°';
      document.getElementById('val-r-knee').textContent = pose.rightKneeBend + 'Â°';
      document.getElementById('val-stance').textContent = pose.stanceWidth + ' cm';

      // Apply poses
      resetMannequinPose(fighterA);
      resetMannequinPose(fighterB);
      poseMannequin(fighterA, poseA);
      poseMannequin(fighterB, poseB);

      // Update distance
      const distance = document.getElementById('distance').value;
      const distanceMap = { 'c': 1.5, 's': 2.5, 'm': 4, 'l': 6, 'v': 8 };
      const dist = distanceMap[distance];
      fighterA.position.x = -dist / 2;
      fighterB.position.x = dist / 2;

      // Update MPN output
      updateMPNOutput();
    }

    function updateMPNOutput() {
      const distance = document.getElementById('distance').value;
      const mpnA = poseToMPN(poseA);
      const mpnB = poseToMPN(poseB);
      document.getElementById('mpn-output').textContent = `${mpnA}/${mpnB}/${distance}`;
    }

    function poseToMPN(pose) {
      return `${pose.leanForwardBack},${pose.leanLeftRight}.${pose.hipRotation},${pose.torsoRotation},${pose.neckRotation}.${pose.leftShoulderPitch},${pose.leftShoulderRoll},${pose.rightShoulderPitch},${pose.rightShoulderRoll}.${pose.leftElbowBend},${pose.rightElbowBend}.${pose.leftHipPitch},${pose.leftHipRoll},${pose.rightHipPitch},${pose.rightHipRoll}.${pose.leftKneeBend},${pose.rightKneeBend}.${pose.stanceWidth},90`;
    }

    function resetMannequinPose(mannequin) {
      mannequin.rotation.set(0, mannequin.rotation.y, 0);
      mannequin.traverse((obj) => {
        if (obj.isGroup || obj.isMesh) {
          if (obj.name !== 'leftLeg' && obj.name !== 'rightLeg') {
            obj.rotation.set(0, 0, 0);
          }
        }
      });

      const leftLeg = mannequin.getObjectByName('leftLeg');
      const rightLeg = mannequin.getObjectByName('rightLeg');
      if (leftLeg) leftLeg.position.x = 0;
      if (rightLeg) rightLeg.position.x = 0;
    }

    function calculateLegBiomechanics(stanceWidthCm) {
      // Calculate proper leg angles based on biomechanics
      // When legs spread, they form triangles - can't stay straight

      const stanceM = stanceWidthCm / 100.0; // Convert to meters
      const hipWidth = 0.30; // Hip joint separation (30cm)
      const thighLength = 0.45; // Thigh length (45cm)
      const shinLength = 0.45; // Shin length (45cm)
      const totalLegLength = thighLength + shinLength;

      // Calculate how far each foot is from its hip joint
      const footOffset = stanceM / 2; // Foot position from center
      const hipJointOffset = hipWidth / 2; // Hip joint from center
      const horizontalDistance = Math.abs(footOffset - hipJointOffset);

      // For a given stance width, calculate the leg angle from vertical
      // This assumes hips stay at same height and legs must reach the ground
      const legAngleFromVertical = Math.atan(horizontalDistance / totalLegLength);
      const legAngleDeg = THREE.MathUtils.radToDeg(legAngleFromVertical);

      // Calculate knee bend needed to maintain hip height
      // Wider stance = more knee bend to keep hips level
      // Simple model: knee bend increases with stance width
      const baseKneeBend = 15; // Minimum bend even in narrow stance
      const additionalBend = legAngleDeg * 1.2; // More bend as legs angle out
      const kneeBend = baseKneeBend + additionalBend;

      // Calculate hip roll (legs spreading sideways)
      const hipRoll = legAngleDeg * 0.6; // Hips roll out as legs spread

      return {
        kneeBend: Math.min(kneeBend, 45), // Cap at 45Â° for realistic squat
        hipRoll: Math.min(hipRoll, 25), // Cap hip roll
        legAngle: legAngleDeg
      };
    }

    function poseMannequin(mannequin, pose) {
      // Torso angle from hips - lean is now in degrees, not cm
      const hips = mannequin.getObjectByName('hips');
      const torso = mannequin.getObjectByName('torso');
      const neck = mannequin.getObjectByName('neck');
      const head = mannequin.getObjectByName('head');

      // Convert lean angles to radians
      // rotation.x = forward/back lean (pitch around x-axis)
      // rotation.z = left/right lean (roll around z-axis)
      const leanFBRad = THREE.MathUtils.degToRad(pose.leanForwardBack);
      const leanLRRad = THREE.MathUtils.degToRad(pose.leanLeftRight);

      // Torso gets the full lean angle (torso angle from hip)
      if (torso) {
        torso.rotation.x = leanFBRad;  // Forward/back
        torso.rotation.z = leanLRRad;  // Left/right
        torso.rotation.y = THREE.MathUtils.degToRad(pose.torsoRotation);
      }

      // Hips stay level (no lean)
      if (hips) {
        hips.rotation.y = THREE.MathUtils.degToRad(pose.hipRotation);
      }

      if (neck) neck.rotation.y = THREE.MathUtils.degToRad(pose.neckRotation);
      if (head) head.rotation.y = THREE.MathUtils.degToRad(pose.neckRotation);

      // Shoulders
      const lShoulder = mannequin.getObjectByName('leftShoulder');
      const rShoulder = mannequin.getObjectByName('rightShoulder');

      if (lShoulder) {
        lShoulder.rotation.x = THREE.MathUtils.degToRad(-pose.leftShoulderPitch);
        lShoulder.rotation.z = THREE.MathUtils.degToRad(-pose.leftShoulderRoll); // Negative = arm goes outward
      }

      if (rShoulder) {
        rShoulder.rotation.x = THREE.MathUtils.degToRad(-pose.rightShoulderPitch);
        rShoulder.rotation.z = THREE.MathUtils.degToRad(pose.rightShoulderRoll); // Positive = arm goes outward
      }

      // Elbows (negative because elbow bends bring forearm UP/back, not down)
      const lElbow = mannequin.getObjectByName('leftElbow');
      const rElbow = mannequin.getObjectByName('rightElbow');

      if (lElbow) lElbow.rotation.x = THREE.MathUtils.degToRad(-pose.leftElbowBend);
      if (rElbow) rElbow.rotation.x = THREE.MathUtils.degToRad(-pose.rightElbowBend);

      // Hips and Knees - calculate biomechanically correct angles from stance width
      const lHip = mannequin.getObjectByName('leftHip');
      const rHip = mannequin.getObjectByName('rightHip');
      const lKnee = mannequin.getObjectByName('leftKnee');
      const rKnee = mannequin.getObjectByName('rightKnee');

      // Calculate biomechanics from stance width
      const legBio = calculateLegBiomechanics(pose.stanceWidth);

      // Apply hip angles - use biomechanically calculated roll unless overridden by kicks
      const leftHipPitchFinal = pose.leftHipPitch !== 0 ? pose.leftHipPitch : 0;
      const rightHipPitchFinal = pose.rightHipPitch !== 0 ? pose.rightHipPitch : 0;

      // Use calculated hip roll from stance width unless explicitly set
      const leftHipRollFinal = pose.leftHipRoll !== 0 ? pose.leftHipRoll : legBio.hipRoll;
      const rightHipRollFinal = pose.rightHipRoll !== 0 ? pose.rightHipRoll : -legBio.hipRoll;

      if (lHip) {
        lHip.rotation.x = THREE.MathUtils.degToRad(-leftHipPitchFinal);
        lHip.rotation.z = THREE.MathUtils.degToRad(leftHipRollFinal);
      }

      if (rHip) {
        rHip.rotation.x = THREE.MathUtils.degToRad(-rightHipPitchFinal);
        rHip.rotation.z = THREE.MathUtils.degToRad(rightHipRollFinal);
      }

      // Apply knee bend - use biomechanically calculated bend unless overridden
      // (for kicks, explicit knee bend is set, otherwise use calculated from stance)
      const leftKneeFinal = pose.leftKneeBend !== 15 ? pose.leftKneeBend : legBio.kneeBend;
      const rightKneeFinal = pose.rightKneeBend !== 15 ? pose.rightKneeBend : legBio.kneeBend;

      // NOTE: Swapped because controls were reversed
      if (lKnee) lKnee.rotation.x = THREE.MathUtils.degToRad(rightKneeFinal);
      if (rKnee) rKnee.rotation.x = THREE.MathUtils.degToRad(leftKneeFinal);

      // Stance width - position the legs
      const leftLeg = mannequin.getObjectByName('leftLeg');
      const rightLeg = mannequin.getObjectByName('rightLeg');
      const stanceM = pose.stanceWidth / 100.0;

      if (leftLeg) leftLeg.position.x = -stanceM / 2;
      if (rightLeg) rightLeg.position.x = stanceM / 2;
    }

    function resetPose() {
      if (currentFighter === 'A') {
        poseA = createNeutralPose();
        loadPoseToUI(poseA);
      } else {
        poseB = createNeutralPose();
        loadPoseToUI(poseB);
      }
    }

    function resetBoth() {
      poseA = createNeutralPose();
      poseB = createNeutralPose();
      loadPoseToUI(currentFighter === 'A' ? poseA : poseB);
    }

    function randomPose() {
      const pose = {
        leanForwardBack: Math.floor((Math.random() - 0.5) * 90), // -45 to 45 degrees
        leanLeftRight: Math.floor((Math.random() - 0.5) * 90), // -45 to 45 degrees
        hipRotation: Math.floor((Math.random() - 0.5) * 60),
        torsoRotation: Math.floor((Math.random() - 0.5) * 60),
        neckRotation: Math.floor((Math.random() - 0.5) * 80),
        leftShoulderPitch: Math.floor(-30 + Math.random() * 150),
        leftShoulderRoll: Math.floor(Math.random() * 120),
        rightShoulderPitch: Math.floor(-30 + Math.random() * 150),
        rightShoulderRoll: Math.floor(Math.random() * 120),
        leftElbowBend: Math.floor(Math.random() * 140),
        rightElbowBend: Math.floor(Math.random() * 140),
        leftHipPitch: Math.floor(-30 + Math.random() * 230), // -30 to 200 for high kicks
        leftHipRoll: Math.floor((Math.random() - 0.5) * 60),
        rightHipPitch: Math.floor(-30 + Math.random() * 230), // -30 to 200 for high kicks
        rightHipRoll: Math.floor((Math.random() - 0.5) * 60),
        leftKneeBend: Math.floor(Math.random() * 120),
        rightKneeBend: Math.floor(Math.random() * 120),
        stanceWidth: Math.floor(25 + Math.random() * 50)
      };

      if (currentFighter === 'A') {
        poseA = pose;
      } else {
        poseB = pose;
      }
      loadPoseToUI(pose);
    }

    function loadPreset(preset) {
      let pose;
      switch(preset) {
        case 'neutral':
          pose = createNeutralPose();
          break;
        case 'jab':
          pose = {
            ...createNeutralPose(),
            leanForwardBack: 8,
            hipRotation: 10,
            torsoRotation: 15,
            leftShoulderPitch: 45,
            leftShoulderRoll: 0,
            leftElbowBend: 20,
            rightShoulderPitch: -20,
            rightShoulderRoll: 30
          };
          break;
        case 'guard':
          pose = {
            ...createNeutralPose(),
            leftShoulderPitch: 60,
            leftShoulderRoll: 20,
            rightShoulderPitch: 60,
            rightShoulderRoll: 20,
            leftElbowBend: 100,
            rightElbowBend: 100
          };
          break;
        case 'kick':
          pose = {
            ...createNeutralPose(),
            leanForwardBack: -5,
            hipRotation: 15,
            torsoRotation: -10,
            rightHipPitch: 90,
            rightKneeBend: 30,
            leftKneeBend: 25,
            stanceWidth: 25
          };
          break;
        case 'highkick':
          pose = {
            ...createNeutralPose(),
            leanForwardBack: -25, // Lean torso backward
            hipRotation: 20, // Pelvis rotates forward
            torsoRotation: -15, // Torso counters
            rightHipPitch: 170, // High kick to head level
            rightKneeBend: 15, // Nearly extended leg
            leftKneeBend: 20, // Standing leg slightly bent
            leftHipPitch: -10, // Standing leg stable
            stanceWidth: 30
          };
          break;
      }

      if (currentFighter === 'A') {
        poseA = pose;
      } else {
        poseB = pose;
      }
      loadPoseToUI(pose);
    }

    // Mouse controls
    let mouseDown = false;
    let mouseX = 0, mouseY = 0;
    let cameraAngle = 0;
    let cameraHeight = 2;
    let cameraDistance = 6;

    function setupMouseControls() {
      const container = document.getElementById('canvas-container');

      container.addEventListener('mousedown', (e) => {
        mouseDown = true;
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      container.addEventListener('mouseup', () => {
        mouseDown = false;
      });

      container.addEventListener('mousemove', (e) => {
        if (!mouseDown) return;

        const deltaX = e.clientX - mouseX;
        const deltaY = e.clientY - mouseY;

        cameraAngle += deltaX * 0.01;
        cameraHeight = Math.max(0.5, Math.min(5, cameraHeight - deltaY * 0.01));

        mouseX = e.clientX;
        mouseY = e.clientY;

        updateCamera();
      });

      container.addEventListener('wheel', (e) => {
        e.preventDefault();
        cameraDistance = Math.max(2, Math.min(12, cameraDistance + e.deltaY * 0.01));
        updateCamera();
      });
    }

    function updateCamera() {
      camera.position.x = Math.sin(cameraAngle) * cameraDistance;
      camera.position.z = Math.cos(cameraAngle) * cameraDistance;
      camera.position.y = cameraHeight;
      camera.lookAt(0, 2, 0);
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const container = document.getElementById('canvas-container');
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }

    // Initialize
    init();
  </script>
</body>
</html>
